> 该系列文章基于 `github.com/shareAI-lab/learn-claude-code` 写就，该仓库以大道至简的风格剖析了Claude Code的核心原理，值得大家学习。由于该仓库是基于Python语言，为方便.NET开发者学习，我已经将代码基于.NET 10的`dotnet file` 重写，源码已上传至github，源码地址见文末。

# v9: 团队协议 - 一个 FSM，两种应用

> 本文是 Learn Claude Code (C# 版) 系列的第十篇，对应代码文件 `v9_team_protocols.cs`。

## 问题：队友无法优雅协调

v8 有了团队，但通信是自由格式的——就像一间没有会议流程的办公室：

```
Lead: "fe-dev, please stop working"
fe-dev: (收到消息, 但如何"停止"? 什么时候算"停下来了"?)

Lead: "Here's the plan, please review it"
fe-dev: (review 了, 然后呢? 怎么告诉 Lead 批准还是拒绝?)
```

缺少**结构化协议**：
- 没有确认机制：关机请求发出后，不知道对方是否已安全停止
- 没有审批流程：计划需要队友投票，但没有状态追踪
- 没有请求关联：多个同时进行的请求无法区分

## 解决方案：request_id 握手模式

同一个 `request_id` 握手模式驱动了关机和计划审批两种协议——一个 FSM，两种应用。

```
             关机协议
Lead                          Teammate
  |                              |
  |-- shutdown_request --------->|  (request_id=abc)
  |   state: PENDING             |
  |                              |
  |<-- shutdown_response --------|  (request_id=abc, ack)
  |   state: CONFIRMED           |
  |                              |
  |== check_shutdown(abc) ==>    |
  |   returns: CONFIRMED ✓       |

             计划审批协议
Lead                          Teammate
  |                              |
  |-- plan_approval ------------>|  (request_id=xyz, plan="...")
  |   state: PENDING             |
  |                              |
  |<-- plan_approval_response ---|  (request_id=xyz, approved=true)
  |   state: APPROVED ✓          |
```

## request_id 追踪

使用 `ConcurrentDictionary` 追踪每个请求的状态：

```csharp
// Lead 侧
ConcurrentDictionary<string, Dictionary<string, string>> shutdownRequests = new();
ConcurrentDictionary<string, Dictionary<string, string>> planRequests = new();
```

### 发送关机请求

```csharp
string HandleShutdownRequest(string teammate)
{
    var requestId = Guid.NewGuid().ToString("N")[..8];

    shutdownRequests[requestId] = new()
    {
        ["teammate"] = teammate,
        ["status"] = "pending"
    };

    messageBus.Send("lead", teammate,
        JsonSerializer.Serialize(new { request_id = requestId }),
        "shutdown_request");

    return $"Shutdown request sent. request_id={requestId}";
}
```

### 检查关机状态

```csharp
string CheckShutdown(string requestId)
{
    // 先排空 lead 的收件箱, 处理可能收到的 shutdown_response
    DrainLeadInbox();

    if (!shutdownRequests.TryGetValue(requestId, out var req))
        return "Unknown request_id";

    return req["status"];  // "pending" | "confirmed"
}
```

### Teammate 侧的响应

```csharp
// Teammate 收到 shutdown_request 时
"shutdown_response" => {
    var requestId = input["request_id"];
    messageBus.Send(name, "lead",
        JsonSerializer.Serialize(new { request_id = requestId, status = "confirmed" }),
        "shutdown_response");
    shouldStop = true;  // 设置退出标志
    return "Acknowledged shutdown.";
}
```

## 计划审批协议

同样的模式，不同的应用：

```csharp
string HandlePlanReview(string teammate, string plan)
{
    var requestId = Guid.NewGuid().ToString("N")[..8];

    planRequests[requestId] = new()
    {
        ["teammate"] = teammate,
        ["status"] = "pending",
        ["plan"] = plan
    };

    messageBus.Send("lead", teammate,
        JsonSerializer.Serialize(new { request_id = requestId, plan }),
        "plan_approval");

    return $"Plan sent for review. request_id={requestId}";
}
```

Teammate 侧：

```csharp
"plan_approval" => {
    var requestId = input["request_id"];
    var decision = input["approved"];  // true/false
    messageBus.Send(name, "lead",
        JsonSerializer.Serialize(new { request_id = requestId, approved = decision }),
        "plan_approval_response");
    return $"Plan {(decision ? "approved" : "rejected")}.";
}
```

## 工具扩展

| Lead Agent 新增工具 | 说明 |
|--------------------|------|
| `shutdown_request` | 发送关机请求给指定队友 |
| `check_shutdown` | 检查关机请求状态 |
| `plan_approval` | 发送计划给队友审批 |

| Teammate 新增工具 | 说明 |
|-------------------|------|
| `shutdown_response` | 确认关机请求 |
| `plan_approval` | 批准/拒绝计划 |

## 相对 v8 的变更

| 组件 | 之前 (v8) | 之后 (v9) |
|------|-----------|-----------|
| 通信类型 | 自由格式消息 | 消息 + 结构化协议 |
| 关机 | 无 (线程永远运行) | request_id 握手确认 |
| 审批 | 无 | 计划审批协议 |
| 请求追踪 | 无 | ConcurrentDictionary 状态机 |
| Lead 工具 | 9 | 12 |
| Teammate 工具 | 6 | 8 |

## 设计原理

`request_id` 是协议设计中的经典模式——每个请求带唯一标识符，响应必须回传相同的标识符。这解决了：

- **请求-响应关联**：多个并发请求不会混淆
- **状态追踪**：每个 request_id 就是一个微型状态机（pending → confirmed/approved/rejected）
- **幂等性**：相同 request_id 的重复响应可以安全忽略

两种协议（关机和审批）共享同一个模式但互不干扰，展示了**一个 FSM 框架多种应用**的可扩展性。

## 运行

```bash
dotnet run v9_team_protocols.cs
```

可以尝试的提示：
1. `Spawn alice as a coder. Then request her shutdown.`
2. `List teammates to see alice's status after shutdown approval`
3. `Spawn bob with a risky refactoring task. Review and reject his plan.`
4. `Spawn charlie, have him submit a plan, then approve it.`
5. 输入 `/team` 监控状态
